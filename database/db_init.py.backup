"""
æ•°æ®åº“åˆå§‹åŒ–æ¨¡å—
è´Ÿè´£åˆ›å»ºæ•°æ®åº“è¡¨ç»“æ„ã€æ‰§è¡Œè¿ç§»å’Œåˆå§‹åŒ–ç³»ç»Ÿé…ç½®
"""

import os
import logging
from typing import Dict, List, Optional
import json
from datetime import datetime, timedelta

# å¯¼å…¥æ•°æ®åº“è¿æ¥ç®¡ç†å™¨
from .db_connection import db_manager

# é…ç½®æ—¥å¿—
logger = logging.getLogger(__name__)

class DatabaseInitializer:
    """æ•°æ®åº“åˆå§‹åŒ–å™¨ç±»"""
    
    def __init__(self):
        """åˆå§‹åŒ–æ•°æ®åº“åˆå§‹åŒ–å™¨"""
        self.schema_version = "1.0"
        self.migration_history = []
    
    async def initialize_database(self) -> bool:
        """
        åˆå§‹åŒ–æ•°æ®åº“
        ä¼˜å…ˆä½¿ç”¨è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨ï¼Œå›é€€åˆ°ä¼ ç»ŸSQLæ–‡ä»¶æ–¹å¼
        
        Returns:
            åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ
        """
        try:
            logger.info("å¼€å§‹åˆå§‹åŒ–æ•°æ®åº“...")
            
            # ä¼˜å…ˆå°è¯•è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨
            try:
                from .db_auto_schema import auto_initialize_database
                logger.info("ğŸš€ ä½¿ç”¨æ™ºèƒ½è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨...")
                
                success = await auto_initialize_database()
                if success:
                    # éªŒè¯è¡¨æ˜¯å¦åˆ›å»ºæˆåŠŸ
                    if await self._verify_tables():
                        logger.info("âœ… è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ")
                        await self._log_initialization()
                        return True
                    else:
                        logger.warning("è‡ªåŠ¨æ¶æ„åˆ›å»ºçš„è¡¨éªŒè¯å¤±è´¥ï¼Œå°è¯•ä¼ ç»Ÿæ–¹å¼...")
                else:
                    logger.warning("è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨åˆå§‹åŒ–å¤±è´¥ï¼Œå°è¯•ä¼ ç»Ÿæ–¹å¼...")
            except Exception as e:
                logger.warning(f"è‡ªåŠ¨æ¶æ„ç®¡ç†å™¨å¤±è´¥: {e}ï¼Œå°è¯•ä¼ ç»Ÿæ–¹å¼...")
            
            # å›é€€åˆ°ä¼ ç»ŸSQLæ–‡ä»¶æ–¹å¼
            logger.info("ğŸ“ ä½¿ç”¨ä¼ ç»ŸSQLæ–‡ä»¶æ–¹å¼åˆå§‹åŒ–...")
            return await self._initialize_with_sql_files()
                
        except Exception as e:
            logger.error(f"æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    async def _initialize_with_sql_files(self) -> bool:
        """ä½¿ç”¨ä¼ ç»ŸSQLæ–‡ä»¶æ–¹å¼åˆå§‹åŒ–æ•°æ®åº“"""
        try:
            # è¯»å–å¹¶æ‰§è¡Œä¸»SQLæ¶æ„æ–‡ä»¶
            schema_path = os.path.join(os.path.dirname(__file__), 'schema.sql')
            
            if not os.path.exists(schema_path):
                logger.error(f"æ‰¾ä¸åˆ°æ¶æ„æ–‡ä»¶: {schema_path}")
                return False
            
            with open(schema_path, 'r', encoding='utf-8') as f:
                schema_sql = f.read()
            
            # åˆ†å‰²SQLè¯­å¥å¹¶æ‰§è¡Œ
            sql_statements = [stmt.strip() for stmt in schema_sql.split(';') if stmt.strip()]
            
            for statement in sql_statements:
                if statement:
                    await db_manager.execute_query(statement)
                    logger.debug(f"æ‰§è¡ŒSQLè¯­å¥: {statement[:50]}...")
            
            # è¯»å–å¹¶æ‰§è¡Œæ‰©å±•æ¶æ„æ–‡ä»¶ï¼ˆæ–°ä¸Šæ¦œæµç¨‹ï¼‰
            extended_schema_path = os.path.join(os.path.dirname(__file__), 'schema_extended.sql')
            
            if os.path.exists(extended_schema_path):
                logger.info("æ‰§è¡Œæ‰©å±•æ¶æ„ï¼ˆæ–°ä¸Šæ¦œæµç¨‹ï¼‰...")
                
                with open(extended_schema_path, 'r', encoding='utf-8') as f:
                    extended_sql = f.read()
                
                # åˆ†å‰²SQLè¯­å¥å¹¶æ‰§è¡Œï¼ˆå¿½ç•¥ALTER TABLEé”™è¯¯ï¼Œå› ä¸ºå­—æ®µå¯èƒ½å·²å­˜åœ¨ï¼‰
                extended_statements = [stmt.strip() for stmt in extended_sql.split(';') if stmt.strip()]
                
                for statement in extended_statements:
                    if statement:
                        try:
                            await db_manager.execute_query(statement)
                            logger.debug(f"æ‰§è¡Œæ‰©å±•SQLè¯­å¥: {statement[:50]}...")
                        except Exception as e:
                            # ALTER TABLEè¯­å¥å¯èƒ½å› å­—æ®µå·²å­˜åœ¨è€Œå¤±è´¥ï¼Œè¿™æ˜¯æ­£å¸¸çš„
                            if "ALTER TABLE" in statement and ("duplicate column name" in str(e).lower() or "already exists" in str(e).lower()):
                                logger.debug(f"å­—æ®µå·²å­˜åœ¨ï¼Œè·³è¿‡: {statement[:50]}...")
                            else:
                                logger.warning(f"æ‰©å±•SQLè¯­å¥æ‰§è¡Œè­¦å‘Š: {statement[:50]}..., é”™è¯¯: {e}")
                
                logger.info("æ‰©å±•æ¶æ„æ‰§è¡Œå®Œæˆ")
            else:
                logger.warning("æ‰©å±•æ¶æ„æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡æ–°ä¸Šæ¦œæµç¨‹åŠŸèƒ½åˆå§‹åŒ–")
            
            # è¯»å–å¹¶æ‰§è¡Œè‡ªåŠ¨å›å¤æ¶æ„æ–‡ä»¶
            auto_reply_schema_path = os.path.join(os.path.dirname(__file__), 'schema_auto_reply.sql')
            
            if os.path.exists(auto_reply_schema_path):
                logger.info("æ‰§è¡Œè‡ªåŠ¨å›å¤åŠŸèƒ½æ¶æ„...")
                
                with open(auto_reply_schema_path, 'r', encoding='utf-8') as f:
                    auto_reply_sql = f.read()
                
                # åˆ†å‰²SQLè¯­å¥å¹¶æ‰§è¡Œ
                auto_reply_statements = [stmt.strip() for stmt in auto_reply_sql.split(';') if stmt.strip()]
                
                for statement in auto_reply_statements:
                    if statement:
                        await db_manager.execute_query(statement)
                        logger.debug(f"æ‰§è¡Œè‡ªåŠ¨å›å¤SQLè¯­å¥: {statement[:50]}...")
                
                logger.info("è‡ªåŠ¨å›å¤åŠŸèƒ½æ¶æ„æ‰§è¡Œå®Œæˆ")
            else:
                logger.warning("è‡ªåŠ¨å›å¤æ¶æ„æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè·³è¿‡è‡ªåŠ¨å›å¤åŠŸèƒ½åˆå§‹åŒ–")
            
            # éªŒè¯è¡¨æ˜¯å¦åˆ›å»ºæˆåŠŸ
            if await self._verify_tables():
                logger.info("ä¼ ç»ŸSQLæ–‡ä»¶åˆå§‹åŒ–æˆåŠŸ")
                await self._log_initialization()
                return True
            else:
                logger.error("æ•°æ®åº“è¡¨éªŒè¯å¤±è´¥")
                return False
                
        except Exception as e:
            logger.error(f"ä¼ ç»ŸSQLæ–‡ä»¶åˆå§‹åŒ–å¤±è´¥: {e}")
            return False
    
    async def _verify_tables(self) -> bool:
        """
        éªŒè¯æ‰€æœ‰å¿…éœ€çš„è¡¨æ˜¯å¦å­˜åœ¨
        
        Returns:
            æ‰€æœ‰è¡¨æ˜¯å¦éƒ½å­˜åœ¨
        """
        required_tables = [
            'merchants', 'orders', 'binding_codes', 'button_configs',
            'activity_logs', 'fsm_states', 'system_config',
            'auto_reply_triggers', 'auto_reply_messages', 'auto_reply_daily_stats',
            'provinces', 'cities', 'keywords', 'merchant_keywords'
        ]
        
        try:
            for table in required_tables:
                result = await db_manager.fetch_one(
                    "SELECT name FROM sqlite_master WHERE type='table' AND name=?",
                    (table,)
                )
                
                if not result:
                    logger.error(f"è¡¨ {table} ä¸å­˜åœ¨")
                    return False
                    
                logger.debug(f"è¡¨ {table} éªŒè¯æˆåŠŸ")
            
            logger.info("æ‰€æœ‰æ•°æ®åº“è¡¨éªŒè¯æˆåŠŸ")
            return True
            
        except Exception as e:
            logger.error(f"è¡¨éªŒè¯å¤±è´¥: {e}")
            return False
    
    async def _log_initialization(self):
        """è®°å½•åˆå§‹åŒ–æ—¥å¿—"""
        try:
            await db_manager.execute_query(
                """INSERT INTO activity_logs (user_id, action_type, details, timestamp) 
                   VALUES (?, ?, ?, ?)""",
                (
                    0,  # ç³»ç»Ÿç”¨æˆ·ID
                    'system_init',
                    json.dumps({
                        'action': 'database_initialized',
                        'schema_version': self.schema_version,
                        'timestamp': datetime.now().isoformat()
                    }, ensure_ascii=False),
                    datetime.now()
                )
            )
            logger.info("æ•°æ®åº“åˆå§‹åŒ–æ—¥å¿—è®°å½•å®Œæˆ")
        except Exception as e:
            logger.warning(f"è®°å½•åˆå§‹åŒ–æ—¥å¿—å¤±è´¥: {e}")
    
    async def get_schema_version(self) -> Optional[str]:
        """
        è·å–å½“å‰æ•°æ®åº“æ¶æ„ç‰ˆæœ¬
        
        Returns:
            æ¶æ„ç‰ˆæœ¬å­—ç¬¦ä¸²
        """
        try:
            result = await db_manager.fetch_one(
                "SELECT config_value FROM system_config WHERE config_key = ?",
                ('schema_version',)
            )
            return result[0] if result else None
        except Exception as e:
            logger.error(f"è·å–æ¶æ„ç‰ˆæœ¬å¤±è´¥: {e}")
            return None
    
    async def update_schema_version(self, version: str) -> bool:
        """
        æ›´æ–°æ•°æ®åº“æ¶æ„ç‰ˆæœ¬
        
        Args:
            version: æ–°çš„ç‰ˆæœ¬å·
            
        Returns:
            æ›´æ–°æ˜¯å¦æˆåŠŸ
        """
        try:
            await db_manager.execute_query(
                """INSERT OR REPLACE INTO system_config (config_key, config_value, description) 
                   VALUES (?, ?, ?)""",
                ('schema_version', version, 'æ•°æ®åº“æ¶æ„ç‰ˆæœ¬')
            )
            logger.info(f"æ¶æ„ç‰ˆæœ¬æ›´æ–°ä¸º: {version}")
            return True
        except Exception as e:
            logger.error(f"æ›´æ–°æ¶æ„ç‰ˆæœ¬å¤±è´¥: {e}")
            return False
    
    async def run_migration(self, migration_name: str, migration_sql: str) -> bool:
        """
        æ‰§è¡Œæ•°æ®åº“è¿ç§»
        
        Args:
            migration_name: è¿ç§»åç§°
            migration_sql: è¿ç§»SQLè¯­å¥
            
        Returns:
            è¿ç§»æ˜¯å¦æˆåŠŸ
        """
        try:
            logger.info(f"å¼€å§‹æ‰§è¡Œè¿ç§»: {migration_name}")
            
            # æ£€æŸ¥è¿ç§»æ˜¯å¦å·²ç»æ‰§è¡Œè¿‡
            if await self._is_migration_applied(migration_name):
                logger.info(f"è¿ç§» {migration_name} å·²ç»æ‰§è¡Œè¿‡ï¼Œè·³è¿‡")
                return True
            
            # æ‰§è¡Œè¿ç§»SQL
            sql_statements = [stmt.strip() for stmt in migration_sql.split(';') if stmt.strip()]
            
            for statement in sql_statements:
                if statement:
                    await db_manager.execute_query(statement)
            
            # è®°å½•è¿ç§»å†å²
            await self._record_migration(migration_name)
            
            logger.info(f"è¿ç§» {migration_name} æ‰§è¡ŒæˆåŠŸ")
            return True
            
        except Exception as e:
            logger.error(f"è¿ç§» {migration_name} æ‰§è¡Œå¤±è´¥: {e}")
            return False
    
    async def _is_migration_applied(self, migration_name: str) -> bool:
        """æ£€æŸ¥è¿ç§»æ˜¯å¦å·²ç»åº”ç”¨"""
        try:
            # é¦–å…ˆç¡®ä¿è¿ç§»å†å²è¡¨å­˜åœ¨
            await db_manager.execute_query("""
                CREATE TABLE IF NOT EXISTS migration_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    migration_name TEXT UNIQUE NOT NULL,
                    applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            """)
            
            result = await db_manager.fetch_one(
                "SELECT migration_name FROM migration_history WHERE migration_name = ?",
                (migration_name,)
            )
            return result is not None
        except Exception as e:
            logger.error(f"æ£€æŸ¥è¿ç§»çŠ¶æ€å¤±è´¥: {e}")
            return False
    
    async def _record_migration(self, migration_name: str):
        """è®°å½•è¿ç§»å†å²"""
        try:
            await db_manager.execute_query(
                "INSERT INTO migration_history (migration_name) VALUES (?)",
                (migration_name,)
            )
        except Exception as e:
            logger.error(f"è®°å½•è¿ç§»å†å²å¤±è´¥: {e}")
    
    async def cleanup_expired_data(self):
        """æ¸…ç†è¿‡æœŸæ•°æ®"""
        try:
            logger.info("å¼€å§‹æ¸…ç†è¿‡æœŸæ•°æ®...")
            
            # æ¸…ç†è¿‡æœŸçš„ç»‘å®šç 
            expired_time = datetime.now() - timedelta(hours=24)
            result = await db_manager.execute_query(
                "DELETE FROM binding_codes WHERE expires_at < ? AND is_used = FALSE",
                (expired_time,)
            )
            logger.info(f"æ¸…ç†äº† {result} ä¸ªè¿‡æœŸç»‘å®šç ")
            
            # æ¸…ç†æ—§çš„æ´»åŠ¨æ—¥å¿—ï¼ˆä¿ç•™30å¤©ï¼‰
            old_log_time = datetime.now() - timedelta(days=30)
            result = await db_manager.execute_query(
                "DELETE FROM activity_logs WHERE timestamp < ?",
                (old_log_time,)
            )
            logger.info(f"æ¸…ç†äº† {result} æ¡æ—§æ´»åŠ¨æ—¥å¿—")
            
            # æ¸…ç†æ—§çš„FSMçŠ¶æ€ï¼ˆä¿ç•™7å¤©ï¼‰
            old_state_time = datetime.now() - timedelta(days=7)
            result = await db_manager.execute_query(
                "DELETE FROM fsm_states WHERE updated_at < ?",
                (old_state_time,)
            )
            logger.info(f"æ¸…ç†äº† {result} ä¸ªæ—§FSMçŠ¶æ€")
            
            # æ¸…ç†æ—§çš„è‡ªåŠ¨å›å¤æ¯æ—¥ç»Ÿè®¡ï¼ˆä¿ç•™90å¤©ï¼‰
            old_stats_time = datetime.now() - timedelta(days=90)
            result = await db_manager.execute_query(
                "DELETE FROM auto_reply_daily_stats WHERE stat_date < ?",
                (old_stats_time.date(),)
            )
            logger.info(f"æ¸…ç†äº† {result} æ¡æ—§è‡ªåŠ¨å›å¤ç»Ÿè®¡")
            
            logger.info("è¿‡æœŸæ•°æ®æ¸…ç†å®Œæˆ")
            
        except Exception as e:
            logger.error(f"æ¸…ç†è¿‡æœŸæ•°æ®å¤±è´¥: {e}")
    
    async def get_database_stats(self) -> Dict[str, int]:
        """
        è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯
        
        Returns:
            åŒ…å«å„è¡¨è®°å½•æ•°çš„å­—å…¸
        """
        stats = {}
        tables = [
            'merchants', 'orders', 'binding_codes', 'button_configs', 'activity_logs', 'fsm_states',
            'auto_reply_triggers', 'auto_reply_messages', 'auto_reply_daily_stats',
            'provinces', 'cities', 'keywords', 'merchant_keywords'
        ]
        
        try:
            for table in tables:
                result = await db_manager.fetch_one(f"SELECT COUNT(*) FROM {table}")
                stats[table] = result[0] if result else 0
            
            logger.debug(f"æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯: {stats}")
            return stats
            
        except Exception as e:
            logger.error(f"è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: {e}")
            return {}
    
    async def backup_database(self, backup_path: str) -> bool:
        """
        å¤‡ä»½æ•°æ®åº“
        
        Args:
            backup_path: å¤‡ä»½æ–‡ä»¶è·¯å¾„
            
        Returns:
            å¤‡ä»½æ˜¯å¦æˆåŠŸ
        """
        try:
            import shutil
            
            # ç¡®ä¿å¤‡ä»½ç›®å½•å­˜åœ¨
            os.makedirs(os.path.dirname(backup_path), exist_ok=True)
            
            # å¤åˆ¶æ•°æ®åº“æ–‡ä»¶
            db_path = db_manager.db_path
            shutil.copy2(db_path, backup_path)
            
            logger.info(f"æ•°æ®åº“å¤‡ä»½æˆåŠŸ: {backup_path}")
            return True
            
        except Exception as e:
            logger.error(f"æ•°æ®åº“å¤‡ä»½å¤±è´¥: {e}")
            return False

# åˆ›å»ºå…¨å±€æ•°æ®åº“åˆå§‹åŒ–å™¨å®ä¾‹
db_initializer = DatabaseInitializer()

async def init_database() -> bool:
    """
    åˆå§‹åŒ–æ•°æ®åº“çš„ä¾¿æ·å‡½æ•°
    
    Returns:
        åˆå§‹åŒ–æ˜¯å¦æˆåŠŸ
    """
    return await db_initializer.initialize_database()

async def cleanup_database():
    """æ¸…ç†æ•°æ®åº“çš„ä¾¿æ·å‡½æ•°"""
    await db_initializer.cleanup_expired_data()

async def get_db_stats() -> Dict[str, int]:
    """è·å–æ•°æ®åº“ç»Ÿè®¡ä¿¡æ¯çš„ä¾¿æ·å‡½æ•°"""
    return await db_initializer.get_database_stats()