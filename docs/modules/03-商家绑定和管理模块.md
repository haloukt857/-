# 商家绑定与信息收集模块技术文档 (V2.0)

## 🚨 核心绑定码方法标准 (V2.0唯一接口)

### 统一调用方法 - 所有模块必须遵循
```python
# ✅ 唯一正确的绑定码操作方法
from database.db_binding_codes import binding_codes_manager

# 获取绑定码信息
binding_info = await binding_codes_manager.get_binding_code_info(code)

# 获取所有绑定码
all_codes = await binding_codes_manager.get_all_binding_codes()

# 使用绑定码
await binding_codes_manager.use_binding_code(code, merchant_id, user_id)

# 删除绑定码
await binding_codes_manager.delete_binding_code(code)
```

### 🎯 强制标准
- **唯一管理器**: 只能使用 `binding_codes_manager`
- **统一字段**: 全链路使用 `merchant_id` 字段
- **字符串参数**: 路由使用 `{code}` 字符串类型
- **禁止Service层**: 直接 Route → DB Manager

---

## 模块概述

本模块是商户进入系统的**第一个核心环节**，负责处理新商户的身份绑定、信息收集和提交审批。它取代了旧的固定步骤流程，采用更灵活的对话式交互，最终目标是生成一个信息完整、待管理员审批的帖子记录。

### 业务价值
- **建立永久身份**: 通过绑定码为商户创建与Telegram账号解耦的永久平台ID。
- **自动化信息收集**: 通过机器人引导，自动、完整地收集上榜所需的全部信息（文本、媒体文件等）。
- **连接审批流程**: 将商户提交的完整信息打包，并置为“待审批”状态，无缝对接Web后台的管理员审核工作流。

---

## 数据库设计

本模块依赖以下核心数据表来完成其功能。

### 1. `merchants` (商家/老师信息表)
```sql
CREATE TABLE merchants (
    id INTEGER PRIMARY KEY AUTOINCREMENT,      -- 永久唯一ID, 自动增长
    telegram_chat_id BIGINT NOT NULL,          -- 当前绑定的TG账号ID, 可修改
    name TEXT,                                 -- 商家/老师名称
    username TEXT,                             -- TG用户名 (@handle)
    district_id INTEGER,                       -- 地区ID (关联到districts表)
    price_1 INTEGER,                           -- 价格1
    price_2 INTEGER,                           -- 价格2
    advantages TEXT,                           -- 优点描述
    disadvantages TEXT,                        -- 缺点描述
    basic_skills TEXT,                         -- 自填基本功
    status TEXT NOT NULL DEFAULT 'pending_submission', -- 帖子状态
    publish_time DATETIME,                     -- 期望发布时间
    expiration_time DATETIME,                  -- 帖子到期时间
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 2. `media` (媒体文件表)
```sql
CREATE TABLE media (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    merchant_id INTEGER NOT NULL,              -- 关联到 merchants.id
    telegram_file_id TEXT NOT NULL,            -- Telegram文件的唯一ID
    media_type TEXT NOT NULL,                  -- 文件类型: 'photo' 或 'video'
    sort_order INTEGER DEFAULT 0,              -- 媒体文件排序
    FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE CASCADE
);
```

### 3. `binding_codes` (绑定码表) - **V2.0 统一字段标准**
```sql
CREATE TABLE binding_codes (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    code TEXT UNIQUE NOT NULL,                 -- 唯一的绑定码字符串
    is_used BOOLEAN DEFAULT FALSE,             -- 是否已被使用
    merchant_id INTEGER,                       -- **统一字段**: 关联到使用的 merchants.id
    used_at DATETIME,                          -- 绑定时间
    bound_telegram_username TEXT,              -- 绑定者的TG用户名
    bound_telegram_name TEXT,                  -- 绑定者的TG名称
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP,                      -- 绑定码过期时间
    FOREIGN KEY (merchant_id) REFERENCES merchants(id) ON DELETE SET NULL
);
```

**重要**: V2.0 架构使用统一的 `merchant_id` 字段，**不再使用** `used_by_merchant_id`。

---

## 核心业务逻辑

### 1. 绑定码验证与永久ID创建

这是商户与系统建立连接的第一步，通过 `/bind` 命令触发。

```python
# 伪代码逻辑 - V2.0 统一接口
async def handle_bind_command(message: Message, code: str):
    # 1. 检查绑定码是否存在且未使用 - 使用统一字段
    binding_data = await binding_codes_manager.get_binding_code_info(code)
    if not binding_data or binding_data.get('is_used'):
        await message.answer("绑定码无效或已被使用。")
        return

    # 2. 检查该TG用户是否已绑定过
    user_id = message.from_user.id
    existing_merchant = await merchants_manager.get_merchant_by_telegram_id(user_id)
    if existing_merchant:
        await message.answer(f"您的账号已绑定到商户ID: {existing_merchant['id']}")
        return

    # 3. 创建永久商户记录
    new_merchant = await merchants_manager.create_merchant(telegram_chat_id=user_id, status='pending_submission')
    permanent_id = new_merchant['id']

    # 4. 更新绑定码状态 - 使用统一字段 merchant_id
    await binding_codes_manager.use_binding_code(code, permanent_id, user_id)

    # 5. 启动信息收集流程
    await message.answer(f"绑定成功！您的永久商户ID是 {permanent_id}。现在开始填写资料...")
    await start_information_collection(user_id, permanent_id)
```

### 2. 自动化信息收集

绑定成功后，系统通过FSM（有限状态机）进入一个对话式的收集流程，引导商户逐项提供信息。

- **流程管理**: 使用`aiogram`的FSMContext来跟踪每个用户（商户）当前正在填写的字段。
- **文本信息**: 机器人依次询问“名称”、“价格1”、“优点”等，商户直接在聊天中回复即可。
- **选择项**: 对于“地区”等信息，机器人发送带有选项的内联键盘供商户选择。
- **媒体文件**: 当需要上传图片/视频时，机器人会提示“请直接发送最多6张图片或视频给我”。
    - **后台处理**: Bot会监听用户发送的媒体文件，并仅保存其`telegram_file_id`到`media`表。Web后台需要展示这些媒体文件时，将通过一个特殊的“代理”路由，由服务器实时用Bot身份从Telegram下载并展示，无需转存到外部云存储。
- **完成与提交**: 当所有必需信息都收集完毕后，机器人会向商户展示一个最终确认信息，商户点击“确认提交”后，系统会将`merchants`表中对应记录的`status`字段更新为 `pending_approval`。

---

## Web管理后台接口 - **V2.0 唯一接口标准**

### 绑定码管理接口

**唯一调用链路**: Route → DB Manager（无Service层冗余）

#### 1. 绑定码列表
- **路由**: `GET /binding-codes`
- **函数**: `binding_codes_list(request: Request)`
- **数据源**: `binding_codes_manager.get_all_binding_codes()`
- **统一字段**: 使用 `merchant_id` 显示绑定商户信息

#### 2. 绑定码详情
- **路由**: `GET /binding-codes/{code}/detail`
- **函数**: `binding_code_detail(request: Request)`
- **参数类型**: `code` (string) - **不再使用** `{code_id:int}`
- **数据源**: `binding_codes_manager.get_binding_code_info(code)`

#### 3. 绑定码生成
- **路由**: `GET /binding-codes/generate`
- **路由**: `POST /binding-codes/generate`
- **函数**: `binding_codes_generate_page()` / `binding_codes_generate_action()`

#### 4. 绑定码删除
- **路由**: `POST /binding-codes/{code}/delete`
- **函数**: `binding_code_delete(request: Request)`
- **参数处理**: 通过 `request.path_params.get("code")` 获取字符串参数

#### 5. 绑定码导出
- **路由**: `GET /binding-codes/export`
- **函数**: `binding_codes_export(request: Request)`
- **导出字段**: 统一使用 `merchant_id` 列名（无 `used_by_merchant_id` 残留）

---

## 实际功能总结 (V2.0)

### 核心功能特点
- ✅ **永久ID创建**: 通过绑定码，为商户建立一个稳固的、独立于TG账号的身份ID。
- ✅ **对话式信息收集**: 采用灵活的FSM状态机引导用户完成资料填写，体验流畅。
- ✅ **媒体文件处理**: 支持接收用户发送的图片和视频，并保存其Telegram文件ID用于后续发布。
- ✅ **提交待审**: 收集完成后，自动将帖子状态置为`pending_approval`，启动管理员审核流程。

### 技术特点 - **V2.0 架构标准**
- ✅ **FSM状态机**: 精准管理每个商户的信息收集进度。
- ✅ **数据解耦**: 核心数据表设计清晰，`merchants`表与`media`表通过外键关联。
- ✅ **异步数据库操作**: 所有数据库交互均为异步，保证机器人响应性能。
- ✅ **唯一接口标准**: Route → DB Manager 单一调用链路，无Service层冗余。
- ✅ **统一字段命名**: 全链路使用 `merchant_id` 字段，与数据库schema精确匹配。
- ✅ **字符串参数**: 路由参数统一使用 `{code}` 字符串类型，不再有类型转换错误。

### 架构兼容性
- ✅ **过期文件隔离**: `binding_mgmt_service.py.old` 已标记为过期，避免接口冲突。
- ✅ **唯一装配点**: 所有路由在 `web/app.py` 中直接注册，无重复装配风险。
- ✅ **代码纯净度**: 删除所有未使用的导入和函数，保持架构清晰。

---

## 开发注意事项

### 必须遵循的标准
1. **字段命名**: 统一使用 `merchant_id`，禁用 `used_by_merchant_id`
2. **参数类型**: 路由参数使用字符串 `{code}`，禁用 `{code_id:int}`
3. **调用链路**: 只能通过 `binding_codes_manager` 调用数据库，禁用Service层
4. **错误处理**: 使用 `request.path_params.get("code")` 安全获取参数

### 禁止操作
- ❌ 不得使用 `used_by_merchant_id` 字段名
- ❌ 不得创建新的Service层（已有.old文件标记）
- ❌ 不得使用 `{code_id:int}` 路由参数
- ❌ 不得在 `web/routes/__init__.py` 中添加 `register_routes` 函数

这些标准确保系统维持"唯一方法、唯一接口、与数据库精准匹配、无冗余"的架构原则。
